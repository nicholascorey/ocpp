"""
This type stub file was generated by pyright.
"""

from typing import Callable, TypeVar, overload

from ocpp.v16 import ChargePoint, call, call_result
from ocpp.v16.enums import Action

routables = ...

ChargePointT = TypeVar("ChargePointT", bound=ChargePoint)
CallT = TypeVar("CallT", bound=call.CallMessageType)
ResponseT = TypeVar("ResponseT", bound=call_result.ResponseMessageType)

TypedOcppCallHandler = Callable[[ChargePointT, CallT], ResponseT]
UntypedOcppCallHandler = Callable[..., ResponseT]

TypedHandlerDecorator = Callable[
    [TypedOcppCallHandler[ChargePointT, CallT, ResponseT]],
    UntypedOcppCallHandler[ResponseT],
]
UntypedHandlerDecorator = Callable[
    [UntypedOcppCallHandler[ResponseT]],
    UntypedOcppCallHandler[ResponseT],
]

@overload
def on_typed(
    call_type: type[call.Authorize], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[ChargePointT, call.Authorize, call_result.Authorize]: ...
@overload
def on_typed(
    call_type: type[call.BootNotification], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.BootNotification, call_result.BootNotification
]: ...
@overload
def on_typed(
    call_type: type[call.CancelReservation], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.CancelReservation, call_result.CancelReservation
]: ...
@overload
def on_typed(
    call_type: type[call.CertificateSigned], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.CertificateSigned, call_result.CertificateSigned
]: ...
@overload
def on_typed(
    call_type: type[call.ChangeAvailability], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.ChangeAvailability, call_result.ChangeAvailability
]: ...
@overload
def on_typed(
    call_type: type[call.ChangeConfiguration], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.ChangeConfiguration, call_result.ChangeConfiguration
]: ...
@overload
def on_typed(
    call_type: type[call.ClearCache], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[ChargePointT, call.ClearCache, call_result.ClearCache]: ...
@overload
def on_typed(
    call_type: type[call.ClearChargingProfile], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.ClearChargingProfile, call_result.ClearChargingProfile
]: ...
@overload
def on_typed(
    call_type: type[call.DataTransfer], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.DataTransfer, call_result.DataTransfer
]: ...
@overload
def on_typed(
    call_type: type[call.DeleteCertificate], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.DeleteCertificate, call_result.DeleteCertificate
]: ...
@overload
def on_typed(
    call_type: type[call.DiagnosticsStatusNotification],
    *,
    skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT,
    call.DiagnosticsStatusNotification,
    call_result.DiagnosticsStatusNotification,
]: ...
@overload
def on_typed(
    call_type: type[call.ExtendedTriggerMessage],
    *,
    skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.ExtendedTriggerMessage, call_result.ExtendedTriggerMessage
]: ...
@overload
def on_typed(
    call_type: type[call.FirmwareStatusNotification],
    *,
    skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT,
    call.FirmwareStatusNotification,
    call_result.FirmwareStatusNotification,
]: ...
@overload
def on_typed(
    call_type: type[call.GetCompositeSchedule], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.GetCompositeSchedule, call_result.GetCompositeSchedule
]: ...
@overload
def on_typed(
    call_type: type[call.GetConfiguration], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.GetConfiguration, call_result.GetConfiguration
]: ...
@overload
def on_typed(
    call_type: type[call.GetDiagnostics], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.GetDiagnostics, call_result.GetDiagnostics
]: ...
@overload
def on_typed(
    call_type: type[call.GetInstalledCertificateIds],
    *,
    skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT,
    call.GetInstalledCertificateIds,
    call_result.GetInstalledCertificateIds,
]: ...
@overload
def on_typed(
    call_type: type[call.GetLocalListVersion], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.GetLocalListVersion, call_result.GetLocalListVersion
]: ...
@overload
def on_typed(
    call_type: type[call.GetLog], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[ChargePointT, call.GetLog, call_result.GetLog]: ...
@overload
def on_typed(
    call_type: type[call.Heartbeat], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[ChargePointT, call.Heartbeat, call_result.Heartbeat]: ...
@overload
def on_typed(
    call_type: type[call.InstallCertificate], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.InstallCertificate, call_result.InstallCertificate
]: ...
@overload
def on_typed(
    call_type: type[call.LogStatusNotification], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.LogStatusNotification, call_result.LogStatusNotification
]: ...
@overload
def on_typed(
    call_type: type[call.MeterValues], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[ChargePointT, call.MeterValues, call_result.MeterValues]: ...
@overload
def on_typed(
    call_type: type[call.RemoteStartTransaction],
    *,
    skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.RemoteStartTransaction, call_result.RemoteStartTransaction
]: ...
@overload
def on_typed(
    call_type: type[call.RemoteStopTransaction], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.RemoteStopTransaction, call_result.RemoteStopTransaction
]: ...
@overload
def on_typed(
    call_type: type[call.ReserveNow], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[ChargePointT, call.ReserveNow, call_result.ReserveNow]: ...
@overload
def on_typed(
    call_type: type[call.Reset], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[ChargePointT, call.Reset, call_result.Reset]: ...
@overload
def on_typed(
    call_type: type[call.SecurityEventNotification],
    *,
    skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.SecurityEventNotification, call_result.SecurityEventNotification
]: ...
@overload
def on_typed(
    call_type: type[call.SendLocalList], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.SendLocalList, call_result.SendLocalList
]: ...
@overload
def on_typed(
    call_type: type[call.SetChargingProfile], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.SetChargingProfile, call_result.SetChargingProfile
]: ...
@overload
def on_typed(
    call_type: type[call.SignCertificate], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.SignCertificate, call_result.SignCertificate
]: ...
@overload
def on_typed(
    call_type: type[call.SignedFirmwareStatusNotification],
    *,
    skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT,
    call.SignedFirmwareStatusNotification,
    call_result.SignedFirmwareStatusNotification,
]: ...
@overload
def on_typed(
    call_type: type[call.SignedUpdateFirmware], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.SignedUpdateFirmware, call_result.SignedUpdateFirmware
]: ...
@overload
def on_typed(
    call_type: type[call.StartTransaction], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.StartTransaction, call_result.StartTransaction
]: ...
@overload
def on_typed(
    call_type: type[call.StatusNotification], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.StatusNotification, call_result.StatusNotification
]: ...
@overload
def on_typed(
    call_type: type[call.StopTransaction], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.StopTransaction, call_result.StopTransaction
]: ...
@overload
def on_typed(
    call_type: type[call.TriggerMessage], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.TriggerMessage, call_result.TriggerMessage
]: ...
@overload
def on_typed(
    call_type: type[call.UnlockConnector], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.UnlockConnector, call_result.UnlockConnector
]: ...
@overload
def on_typed(
    call_type: type[call.UpdateFirmware], *, skip_schema_validation: bool = False
) -> TypedHandlerDecorator[
    ChargePointT, call.UpdateFirmware, call_result.UpdateFirmware
]: ...
def on_typed(
    call_type: type[CallT], skip_schema_validation: bool = False
) -> TypedHandlerDecorator[ChargePointT, CallT, ResponseT]: ...
def on(
    action: Action, *, skip_schema_validation: bool = ...
) -> UntypedHandlerDecorator[ResponseT]:
    """
    Function decorator to mark function as handler for specific action. The
    wrapped function may be async or sync.

    The handler function will receive keyword arguments derived from the
    payload of the specific action. It's recommended you use `**kwargs` in your
    definition to ignore any extra arguments that may be added in the future.

    The handler function should return a relevant payload to be returned to the
    Charge Point.

    It can be used like so:

    ```
    class MyChargePoint(cp):
        @on(Action.boot_notification):
        async def on_boot_notification(
            self,
            charge_point_model,
            charge_point_vendor,
            **kwargs,
        ):
            print(f'{charge_point_model} from {charge_point_vendor} booted.')

            now = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S') + "Z"
            return call_result.BootNotificationPayload(
                current_time=now,
                interval=30,
                status="Accepted",
            )
    ```

    The decorator takes an optional argument `skip_schema_validation` which
    defaults to False. Setting this argument to `True` will disable schema
    validation of the request and the response of the specific route.

    """
    ...

def after(action):  # -> Callable[..., _Wrapped[..., Any, ..., Any]]:
    """Function decorator to mark function as hook to post-request hook.

    This hook's arguments are the data that is in the payload for the specific
    action.

    It can be used like so:

        @after(Action.boot_notification):
        def after_boot_notification():
            pass

    """
    ...

def create_route_map(obj):  # -> dict[Any, Any]:
    """
    Iterates of all attributes of the class looking for attributes which
    have been decorated by the @on() decorator It returns a dictionary where
    the action name are the keys and the decorated functions are the values.

    To illustrate this with an example, consider the following function:

        class ChargePoint:

            @on(Action.boot_notification)
            def on_boot_notification(self, *args, **kwargs):
                pass

            @after(Action.boot_notification)
            def after_boot_notification(self, *args, **kwargs):
                pass


    In this case this returns:

        {
            Action.boot_notification: {
                '_on_action': <reference to 'on_boot_notification'>,
                '_after_action': <reference to 'after_boot_notification'>,
                '_skip_schema_validation': False,
            },
        }

    """
    ...
